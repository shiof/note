---
layout: article
title:	JVM学习 - 垃圾收集算法
date:	2019-09-06 18:03:34
categories:
    - article
tags:
    - Java
    - JVM
---

### 标记-清除算法

最基础的收集算法是`标记-清除`（Mark-Sweep）算法，分为`标记`和`清除`两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

但存在两个不足：

1. 效率问题，标记和清除两个过程的效率都不高。

2. 标记清除之后会产生大量不连续的内存碎片。导致分配大对象时，内存不足而不得不提前触发另一次垃圾收集动作。

3. 垃圾回收时，需要挂起（`stop the world`）。

![image](https://user-images.githubusercontent.com/29170657/64579343-21bbae00-d3b5-11e9-9e33-a39ab3862b74.png)

### 复制算法

`复制`算法是为了效率不足的问题，它将可用的内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完之后，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

优点：

1. 不用考虑内存碎片等复杂情况。

2. 实现简单，运行效率高。

缺点：

1. 将内存缩小为了原来的一半，内存利用率不高。

2. 在对象存活率较高时，进行较多的复制操作，效率将会变低。

![image](https://user-images.githubusercontent.com/29170657/64579864-f3d76900-d3b6-11e9-95c6-1165b67c5ade.png)

在新生代中大部分的对象都是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存的空间，而是将内存分为一块较大的`Eden`空间和两块较小的`Survivor`空间。当回收时，将`Eden`和`Survivor`中存活的对象一次性复制到另外一块`Survivor`空间上，最后清除掉`Eden`和刚才用过的`Survivor`空间。

当`Survivor`空间不够用时，需要依赖其他内存（老年代）进行分配。

`Eden`与`Survivor`比例：8:1:1

### 标记-整理算法

过程与`标记-清除`算法一样，但后续不是直接对可收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

![image](https://user-images.githubusercontent.com/29170657/64580702-da83ec00-d3b9-11e9-8415-84beb14272b9.png)

### 分代收集算法

根据对象存活周期的不同将内存划分为几块，一般是把Java的堆分为`新生代`和`老年代`

新生代：每次垃圾收集时都会有大批对象死去，只有少量存活，适合用`复制算法`,只需要付出少量的存活对象的复制成本就可以完成收集。

老年代：对象存活率比较高、没有额外的空间对它进行分配担保，就必须使用`标记-清除`或`标记-整理`算法来进行回收。